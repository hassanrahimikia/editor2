{
  "title": "بسم الله الرحمن الرحیم",
  "cells": [
    {
      "type": "text",
      "content": "پروژه درس هوش مصنوعی\nدانشگاه شمال\nارائه دهنده : حسن رحیمی کیا\nاستاد مربوطه : دکتر فدوی"
    },
    {
      "type": "text",
      "content": "در این پروژه، یک سیستم پیش‌بینی قیمت انرژی با استفاده از الگوریتم Support Vector Regression (SVR) پیاده‌سازی شد که از داده‌های آب‌وهوایی، زمانی، و اقتصادی برای پیش‌بینی استفاده می‌کند. ابتدا یک مجموعه داده مصنوعی با 5000 نمونه شامل شش ویژگی (دما، رطوبت، سرعت باد، روز هفته، ساعت، و قیمت سوخت) تولید شد و سپس قیمت انرژی به صورت ترکیب خطی وزن‌دار این ویژگی‌ها به همراه نویز تصادفی محاسبه گردید. پس از تبدیل داده‌ها به DataFrame پانداس، مجموعه داده به دو بخش آموزشی (80 درصد) و تست (20 درصد) تقسیم شد و ویژگی‌ها با استفاده از StandardScaler نرمال‌سازی شدند تا مدل بتواند بهتر یاد بگیرد. مدل SVR با هسته RBF، پارامتر C=100، و epsilon=0.1 آموزش داده شد و نتایج ارزیابی نشان داد که مدل عملکرد بسیار خوبی دارد با R² برابر 0.84، RMSE حدود 10.30، و MAE حدود 8.13. در نهایت، قابلیت پیش‌بینی قیمت انرژی برای داده‌های جدید نیز پیاده‌سازی شد که در برنامه‌های واقعی برای پیش‌بینی real-time قابل استفاده است. این پروژه یک نمونه کامل از پایپلاین یادگیری ماشین است که شامل تولید/آماده‌سازی داده، پیش‌پردازش، آموزش مدل، ارزیابی، و استقرار (deployment) می‌شود."
    },
    {
      "type": "code",
      "language": "python",
      "content": "import numpy as np\nimport pandas as pd\nfrom sklearn.svm import SVR"
    },
    {
      "type": "text",
      "content": "این تکه کد سه کتابخانه اساسی برای پیاده‌سازی یک پروژه یادگیری ماشین را وارد محیط پایتون می‌کند. در خط اول، NumPy که مخفف Numerical Python است، برای انجام محاسبات عددی پیشرفته و کار با آرایه‌های چندبعدی به صورت کارآمد import می‌شود. خط دوم pandas را وارد می‌کند که ابزاری قدرتمند برای دستکاری داده‌ها، خواندن فایل‌ها، و کار با ساختارهای جدولی مانند DataFrame است و معمولاً در کنار NumPy برای تحلیل داده استفاده می‌شود. در نهایت، خط سوم کلاس SVR (Support Vector Regression) را از ماژول svm کتابخانه scikit-learn وارد می‌کند که یک الگوریتم یادگیری ماشین نظارت‌شده برای حل مسائل رگرسیون و پیش‌بینی مقادیر پیوسته است."
    },
    {
      "type": "code",
      "language": "python",
      "content": "from sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error\n"
    },
    {
      "type": "text",
      "content": "این تکه کد سه ابزار کلیدی از کتابخانه scikit-learn را برای آماده‌سازی داده، تقسیم‌بندی مجموعه داده، و ارزیابی مدل یادگیری ماشین وارد می‌کند. تابع train_test_split از ماژول model_selection برای تقسیم مجموعه داده به دو بخش آموزشی (train) و تست (test) استفاده می‌شود، به طوری که بخش آموزشی برای آموزش مدل و بخش تست برای ارزیابی عملکرد مدل روی داده‌های جدید به کار می‌رود. کلاس StandardScaler از ماژول preprocessing مسئول استاندارد کردن ویژگی‌های داده است، به این معنی که مقادیر را به مقیاس یکسانی تبدیل می‌کند (معمولاً با میانگین صفر و انحراف معیار یک) تا مدل‌های یادگیری ماشین بتوانند بهتر یاد بگیرند و از تأثیر نامتناسب ویژگی‌هایی با مقیاس‌های مختلف جلوگیری شود. در نهایت، سه تابع mean_squared_error، r2_score، و mean_absolute_error از ماژول metrics برای اندازه‌گیری و ارزیابی دقت مدل رگرسیون import شده‌اند که به ترتیب میانگین مربعات خطا، ضریب تعیین (R²)، و میانگین قدر مطلق خطا را محاسبه می‌کنند و به شما کمک می‌کنند بفهمید مدل شما چقدر خوب پیش‌بینی می‌کند."
    },
    {
      "type": "code",
      "language": "python",
      "content": "# تولید دیتاست\nnp.random.seed(42)\nn_samples = 5000\n\ndata = {\n    'temperature': np.random.uniform(-10, 45, n_samples),\n    'humidity': np.random.uniform(20, 100, n_samples),\n    'wind_speed': np.random.uniform(0, 50, n_samples),\n    'day_of_week': np.random.randint(0, 7, n_samples),\n    'hour': np.random.randint(0, 24, n_samples),\n    'fuel_price': np.random.uniform(50, 150, n_samples)\n}\n"
    },
    {
      "type": "text",
      "content": "این تکه کد یک مجموعه داده (دیتاست) تصادفی با 5000 نمونه برای شبیه‌سازی داده‌های مربوط به مصرف سوخت یا انرژی تولید می‌کند. در ابتدا، تابع np.random.seed(42) فراخوانی شده تا بذر (seed) تولیدکننده اعداد تصادفی را ثابت کند، که این کار باعث می‌شود هر بار که کد اجرا شود، دقیقاً همان اعداد تصادفی تولید شوند و نتایج قابل بازتولید باشند. سپس تعداد نمونه‌ها روی 5000 تنظیم شده و یک دیکشنری به نام data ساخته می‌شود که شش ویژگی مختلف دارد. ویژگی‌های temperature (دما بین -10 تا 45 درجه)، humidity (رطوبت بین 20 تا 100 درصد)، wind_speed (سرعت باد بین 0 تا 50)، و fuel_price (قیمت سوخت بین 50 تا 150) با استفاده از تابع np.random.uniform به صورت اعداد اعشاری تصادفی با توزیع یکنواخت در بازه‌های مشخص تولید شده‌اند. همچنین دو ویژگی day_of_week (روز هفته از 0 تا 6) و hour (ساعت از 0 تا 23) با استفاده از تابع np.random.randint به صورت اعداد صحیح تصادفی تولید شده‌اند تا زمان‌بندی را نشان دهند. این دیتاست احتمالاً برای آموزش یک مدل یادگیری ماشین (مانند SVR که در کدهای قبلی import شده) جهت پیش‌بینی مصرف انرژی یا سوخت بر اساس شرایط آب‌وهوایی و زمانی استفاده خواهد شد."
    },
    {
      "type": "code",
      "language": "python",
      "content": "# محاسبه قیمت انرژی با فرمول پیچیده\nenergy_price = (\n    50 + \n    data['temperature'] * 0.8 +\n    data['humidity'] * 0.2 -\n    data['wind_speed'] * 0.3 +\n    data['day_of_week'] * 2 +\n    data['hour'] * 0.5 +\n    data['fuel_price'] * 0.6 +\n    np.random.normal(0, 10, n_samples)\n      # نویز\n)"
    },
    {
      "type": "text",
      "content": "این تکه کد متغیر هدف (target variable) یعنی قیمت انرژی را بر اساس یک فرمول خطی پیچیده از ترکیب وزن‌دار ویژگی‌های مختلف محاسبه می‌کند. در این فرمول، هر ویژگی با یک ضریب مشخص ضرب شده و به یک مقدار پایه (50) اضافه می‌شود، به طوری که دما با ضریب 0.8، رطوبت با 0.2، روز هفته با 2، ساعت با 0.5، و قیمت سوخت با 0.6 تأثیر مثبت دارند، در حالی که سرعت باد با ضریب منفی 0.3 باعث کاهش قیمت انرژی می‌شود. در پایان فرمول، یک نویز تصادفی با استفاده از تابع np.random.normal با میانگین 0 و انحراف معیار 10 به داده‌ها اضافه شده است تا واقعی‌تر شوند و تغییرات غیرقابل پیش‌بینی و اتفاقی را شبیه‌سازی کنند. افزودن نویز به داده‌های مصنوعی (synthetic data) کاری ضروری است، زیرا داده‌های واقعی همیشه دارای خطا و نوسانات تصادفی هستند و بدون نویز، مدل یادگیری ماشین نمی‌تواند به طور واقع‌بینانه‌ای آموزش ببیند و ممکن است عملکرد بهینه‌ای نداشته باشد. این روش تولید داده سنتتیک برای آموزش مدل‌های رگرسیون مانند SVR بسیار رایج است و به مدل کمک می‌کند تا رابطه بین ویژگی‌های ورودی و خروجی را یاد بگیرد."
    },
    {
      "type": "code",
      "language": "python",
      "content": "\ndata['energy_price'] = energy_price\ndf = pd.DataFrame(data)\n\n# تقسیم داده‌ها\nX = df.drop('energy_price', axis=1)\ny = df['energy_price']\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, random_state=42\n)\n"
    },
    {
      "type": "text",
      "content": "این تکه کد ابتدا قیمت انرژی محاسبه‌شده را به دیکشنری data اضافه می‌کند و سپس کل داده‌ها را به یک DataFrame پانداس تبدیل می‌کند که ساختار جدولی مناسبی برای تحلیل و مدل‌سازی فراهم می‌آورد. در مرحله بعد، متغیرهای ورودی (features) و متغیر هدف (target) از هم جدا می‌شوند، به این صورت که X شامل تمام ستون‌ها به جز energy_price است که با استفاده از متد drop و تنظیم axis=1 (که نشان‌دهنده محور ستون‌هاست) حذف می‌شود، و y فقط شامل ستون energy_price است. سپس تابع train_test_split داده‌ها را به طور تصادفی به دو بخش آموزشی و تست تقسیم می‌کند، به طوری که test_size=0.2 مشخص می‌کند 20 درصد از داده‌ها برای تست و 80 درصد باقیمانده برای آموزش مدل استفاده شوند. پارامتر random_state=42 تضمین می‌کند که هر بار که کد اجرا شود، تقسیم‌بندی به همان شکل انجام شود و نتایج قابل بازتولید (reproducible) باشند، چون ژنراتور اعداد تصادفی با یک بذر ثابت کنترل می‌شود. نتیجه این عملیات چهار مجموعه داده است: X_train و y_train برای آموزش مدل، و X_test و y_test برای ارزیابی عملکرد مدل روی داده‌هایی که مدل قبلاً ندیده است."
    },
    {
      "type": "code",
      "language": "python",
      "content": "# نرمال‌سازی\nscaler = StandardScaler()\nX_train_scaled = scaler.fit_transform(X_train)\nX_test_scaled = scaler.transform(X_test)\n"
    },
    {
      "type": "text",
      "content": "این تکه کد فرآیند نرمال‌سازی (استاندارد کردن) ویژگی‌های ورودی را انجام می‌دهد که یکی از مراحل بسیار مهم در پیش‌پردازش داده‌ها برای الگوریتم‌های یادگیری ماشین به خصوص SVR است. در خط اول، یک شیء از کلاس StandardScaler ساخته می‌شود که مسئولیت تبدیل مقیاس داده‌ها را بر عهده دارد. در خط دوم، متد fit_transform روی داده‌های آموزشی (X_train) اعمال می‌شود که در این فرآیند ابتدا پارامترهای لازم مانند میانگین و انحراف معیار هر ویژگی از داده‌های آموزشی محاسبه (fit) می‌شود و سپس بلافاصله این آمارها برای تبدیل داده‌ها استفاده می‌شوند (transform)، به طوری که هر ویژگی به مقیاسی با میانگین صفر و انحراف معیار یک تبدیل می‌شود. نکته حیاتی در خط سوم این است که برای داده‌های تست (X_test) فقط از متد transform استفاده می‌شود و نه fit_transform، زیرا باید از همان پارامترهایی که از روی داده‌های آموزشی یاد گرفته شده استفاده کنیم تا از نشت داده (data leakage) جلوگیری شود و مدل را به درستی ارزیابی کنیم. این نرمال‌سازی به مدل SVR کمک می‌کند تا بهتر یاد بگیرد، چون تمام ویژگی‌ها (دما، رطوبت، سرعت باد و...) که در مقیاس‌های مختلف هستند به یک مقیاس یکسان تبدیل می‌شوند و هیچ ویژگی به دلیل مقدار عددی بزرگ‌تر، تأثیر نامتناسبی بر مدل نخواهد گذاشت."
    },
    {
      "type": "code",
      "language": "python",
      "content": "# ساخت و آموزش مدل SVR\nsvr_model = SVR(kernel='rbf', C=100, epsilon=0.1)\nsvr_model.fit(X_train_scaled, y_train)"
    },
    {
      "type": "text",
      "content": "این تکه کد یک مدل Support Vector Regression (SVR) با پارامترهای خاص ایجاد کرده و سپس آن را روی داده‌های آموزشی نرمال‌شده آموزش می‌دهد. در خط اول، یک شیء SVR با سه پارامتر مهم ساخته می‌شود: پارامتر kernel='rbf' که مشخص می‌کند از هسته RBF (Radial Basis Function) استفاده شود و این هسته برای مدل‌سازی روابط غیرخطی بین ویژگی‌ها و خروجی مناسب است ، پارامتر C=100 که یک پارامتر جریمه (regularization parameter) است و مقدار بالای آن نشان می‌دهد که مدل باید خطاهای آموزشی را به شدت کاهش دهد و به داده‌های آموزشی نزدیک‌تر شود ، و پارامتر epsilon=0.1 که عرض لوله‌ای (epsilon-tube) را تعیین می‌کند که در آن هیچ جریمه‌ای برای نقاطی که در فاصله epsilon از مقدار واقعی پیش‌بینی می‌شوند اعمال نمی‌شود. در خط دوم، متد fit فراخوانی می‌شود که مدل SVR را با استفاده از داده‌های ورودی نرمال‌شده (X_train_scaled) و مقادیر هدف (y_train) آموزش می‌دهد، به طوری که الگوریتم بهترین hyperplane و support vectors را برای مدل‌سازی رابطه بین ویژگی‌ها و قیمت انرژی پیدا می‌کند. انتخاب مقادیر بهینه برای این پارامترها (C، epsilon، و gamma در هسته RBF) بسیار حیاتی است و معمولاً از روش‌هایی مانند Grid Search برای یافتن بهترین ترکیب استفاده می‌شود."
    },
    {
      "type": "code",
      "language": "python",
      "content": "# پیش‌بینی\ny_pred = svr_model.predict(X_test_scaled)\n"
    },
    {
      "type": "text",
      "content": "این تکه کد از مدل SVR آموزش‌دیده برای پیش‌بینی قیمت انرژی روی داده‌های تست استفاده می‌کند. متد predict روی شیء svr_model فراخوانی شده و داده‌های ورودی نرمال‌شده تست (X_test_scaled) به آن ارسال می‌شود تا مدل برای هر نمونه تست، یک مقدار پیوسته پیش‌بینی کند. این متد از الگویی که مدل در حین آموزش یاد گرفته است (شامل support vectors، hyperplane بهینه، و پارامترهای هسته RBF) استفاده می‌کند تا برای داده‌های جدید که مدل قبلاً ندیده است، خروجی محاسبه کند. نتیجه این پیش‌بینی‌ها در متغیر y_pred ذخیره می‌شود که یک آرایه شامل قیمت‌های انرژی پیش‌بینی‌شده برای تمام نمونه‌های تست است. این مقادیر پیش‌بینی‌شده بعداً با مقادیر واقعی (y_test) مقایسه خواهند شد تا عملکرد و دقت مدل با استفاده از معیارهایی مانند MSE، MAE، و R² ارزیابی شود."
    },
    {
      "type": "code",
      "language": "python",
      "content": "# ارزیابی\nmse = mean_squared_error(y_test, y_pred)\nrmse = np.sqrt(mse)\nmae = mean_absolute_error(y_test, y_pred)\nr2 = r2_score(y_test, y_pred)\n"
    },
    {
      "type": "text",
      "content": "این تکه کد چهار معیار اصلی ارزیابی عملکرد مدل رگرسیون را محاسبه می‌کند تا دقت و کیفیت پیش‌بینی‌های مدل SVR را بسنجد. در خط اول، MSE (Mean Squared Error یا میانگین مربعات خطا) با مقایسه مقادیر واقعی (y_test) و پیش‌بینی‌شده (y_pred) محاسبه می‌شود، که در این معیار تفاوت هر پیش‌بینی با مقدار واقعی را به توان دو رسانده و میانگین آنها را می‌گیرد، و به دلیل توان‌دار کردن، خطاهای بزرگ جریمه بیشتری دریافت می‌کنند. خط دوم RMSE (Root Mean Squared Error) را با گرفتن جذر MSE محاسبه می‌کند که مزیت آن این است که واحد آن با واحد متغیر هدف یکسان است و تفسیر آن آسان‌تر است، به طوری که نشان می‌دهد به طور متوسط پیش‌بینی‌های ما چقدر از مقادیر واقعی فاصله دارند. خط سوم MAE (Mean Absolute Error یا میانگین قدر مطلق خطا) را محاسبه می‌کند که قدر مطلق اختلاف بین پیش‌بینی‌ها و مقادیر واقعی را میانگین‌گیری می‌کند و نسبت به MSE و RMSE، به خطاهای بزرگ (outliers) حساسیت کمتری دارد و معیاری قابل‌فهم‌تر و استوارتر است. در نهایت، خط چهارم ضریب تعیین R² (R-squared یا coefficient of determination) را محاسبه می‌کند که عددی بین 0 تا 1 است (گاهی می‌تواند منفی باشد) و نشان می‌دهد مدل چه نسبتی از واریانس داده‌ها را توضیح می‌دهد، به طوری که R²=1 نشان‌دهنده تطابق کامل و R²=0 یعنی مدل بهتر از پیش‌بینی میانگین عمل نمی‌کند. ترکیب این چهار معیار یک دید جامع از عملکرد مدل ارائه می‌دهد و به ما کمک می‌کند تا بفهمیم مدل SVR ما چقدر دقیق کار می‌کند"
    },
    {
      "type": "code",
      "language": "python",
      "content": "print(f'RMSE: {rmse:.2f}')\nprint(f'MAE: {mae:.2f}')\nprint(f'R² Score: {r2:.4f}')\n"
    },
    {
      "type": "text",
      "content": "این تکه کد سه معیار ارزیابی محاسبه‌شده در مرحله قبل را با قالب‌بندی مناسب و خوانا روی صفحه نمایش چاپ می‌کند. برای چاپ از f-string (formatted string literals) استفاده شده که یکی از روش‌های مدرن و راحت قالب‌بندی رشته‌ها در پایتون است و امکان قرار دادن متغیرها به صورت مستقیم درون رشته را فراهم می‌کند. در خط اول، مقدار RMSE با دقت دو رقم اعشار (:.2f) نمایش داده می‌شود که به ما می‌گوید به طور متوسط پیش‌بینی‌های مدل چقدر از مقادیر واقعی فاصله دارند. خط دوم MAE را نیز با دو رقم اعشار چاپ می‌کند که معیاری قابل‌فهم‌تر و مستقیم‌تر از میزان خطای مطلق مدل است. در نهایت، خط سوم ضریب تعیین R² را با دقت چهار رقم اعشار (:.4f) نمایش می‌دهد که این دقت بالاتر به این دلیل است که R² معمولاً عددی بین 0 و 1 است و ارقام اعشار بیشتر برای تشخیص تفاوت‌های ظریف در کیفیت مدل مفید هستند. این خروجی‌ها به شما اجازه می‌دهند که به سرعت کیفیت و دقت مدل SVR خود را ارزیابی کنید و در صورت نیاز تصمیم بگیرید که آیا باید پارامترهای مدل را تنظیم کنید یا از الگوریتم دیگری استفاده کنید."
    },
    {
      "type": "code",
      "language": "python",
      "content": "#خروجی کد:\n#RMSE: 10.30\n#MAE: 8.13\n#R² Score: 0.8422"
    },
    {
      "type": "text",
      "content": "این خروجی نشان می‌دهد که مدل SVR شما عملکرد بسیار خوبی دارد و توانسته است الگوهای موجود در داده‌ها را به خوبی یاد بگیرد. مقدار R² برابر با 0.8422 (یا حدود 84.22 درصد) به این معناست که مدل شما 84 درصد از تغییرات (واریانس) قیمت انرژی را توضیح می‌دهد، که این یک عملکرد قوی محسوب می‌شود و نشان‌دهنده تطابق مناسب مدل با داده‌هاست. مقدار RMSE برابر با 10.30 بیانگر این است که به طور متوسط پیش‌بینی‌های مدل شما حدود 10.30 واحد (احتمالاً واحد پولی) از مقادیر واقعی قیمت انرژی فاصله دارند. همچنین مقدار MAE برابر با 8.13 نشان می‌دهد که میانگین قدر مطلق خطاها حدود 8.13 است، که کمی کمتر از RMSE است و این طبیعی است چون RMSE به خطاهای بزرگ وزن بیشتری می‌دهد. با توجه به اینکه داده‌های شما نویز تصادفی با انحراف معیار 10 داشتند و RMSE تقریباً در همان محدوده قرار گرفته، می‌توان نتیجه گرفت که مدل به خوبی توانسته است سیگنال اصلی را از نویز تفکیک کرده و روابط خطی بین ویژگی‌ها و قیمت انرژی را پیدا کند."
    },
    {
      "type": "code",
      "language": "python",
      "content": "\n# پیش‌بینی داده جدید\nnew_data = [[25, 60, 15, 2, 12, 80]]\nnew_data_scaled = scaler.transform(new_data)\nprediction = svr_model.predict(new_data_scaled)\nprint(f'پیش‌بینی قیمت: {prediction[0]:.2f}')"
    },
    {
      "type": "text",
      "content": "این تکه کد نحوه استفاده از مدل SVR آموزش‌دیده برای پیش‌بینی قیمت انرژی بر اساس داده‌های جدید و واقعی را نشان می‌دهد. در خط اول، یک نمونه داده جدید به صورت لیست دوبعدی (با شش ویژگی) ایجاد می‌شود که شامل دمای 25 درجه، رطوبت 60 درصد، سرعت باد 15، روز هفته 2 (سه‌شنبه)، ساعت 12، و قیمت سوخت 80 است. در خط دوم، بسیار مهم است که این داده جدید با استفاده از همان شیء scaler که قبلاً روی داده‌های آموزشی fit شده بود، فقط با متد transform نرمال‌سازی شود (نه fit_transform)، چون باید از همان میانگین و انحراف معیاری که از داده‌های آموزشی یاد گرفته شده استفاده کنیم تا تبدیل‌ها سازگار باشند. خط سوم مدل SVR را با داده نرمال‌شده فراخوانی می‌کند تا قیمت انرژی پیش‌بینی‌شده را محاسبه کند، که نتیجه یک آرایه است و با استفاده از prediction اولین (و تنها) عنصر آن استخراج می‌شود. در نهایت، خط چهارم قیمت پیش‌بینی‌شده را با دو رقم اعشار و به زبان فارسی چاپ می‌کند تا کاربر بتواند بفهمد در شرایط مشخص‌شده (دمای 25 درجه، ساعت 12 ظهر سه‌شنبه و...) قیمت انرژی چقدر خواهد بود. این روش دقیقاً همان فرآیندی است که در برنامه‌های واقعی برای پیش‌بینی در زمان واقعی (real-time prediction) استفاده می‌شود."
    },
    {
      "type": "code",
      "language": "python",
      "content": "پیش‌بینی قیمت: 136.55"
    },
    {
      "type": "text",
      "content": "کد نهایی پروژه"
    },
    {
      "type": "code",
      "language": "python",
      "content": "import numpy as np\nimport pandas as pd\nfrom sklearn.svm import SVR\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error\n\n\nnp.random.seed(42)\nn_samples = 5000\n\ndata = {\n    'temperature': np.random.uniform(-10, 45, n_samples),\n    'humidity': np.random.uniform(20, 100, n_samples),\n    'wind_speed': np.random.uniform(0, 50, n_samples),\n    'day_of_week': np.random.randint(0, 7, n_samples),\n    'hour': np.random.randint(0, 24, n_samples),\n    'fuel_price': np.random.uniform(50, 150, n_samples)\n}\n\n\nenergy_price = (\n    50 + \n    data['temperature'] * 0.8 +\n    data['humidity'] * 0.2 -\n    data['wind_speed'] * 0.3 +\n    data['day_of_week'] * 2 +\n    data['hour'] * 0.5 +\n    data['fuel_price'] * 0.6 +\n    np.random.normal(0, 10, n_samples)\n     \n)\n\ndata['energy_price'] = energy_price\ndf = pd.DataFrame(data)\n\n\nX = df.drop('energy_price', axis=1)\ny = df['energy_price']\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, random_state=42\n)\n\n\nscaler = StandardScaler()\nX_train_scaled = scaler.fit_transform(X_train)\nX_test_scaled = scaler.transform(X_test)\n\n\nsvr_model = SVR(kernel='rbf', C=100, epsilon=0.1)\nsvr_model.fit(X_train_scaled, y_train)\n\n\ny_pred = svr_model.predict(X_test_scaled)\n\n\nmse = mean_squared_error(y_test, y_pred)\nrmse = np.sqrt(mse)\nmae = mean_absolute_error(y_test, y_pred)\nr2 = r2_score(y_test, y_pred)\nprint(f'RMSE: {rmse:.2f}')\nprint(f'MAE: {mae:.2f}')\nprint(f'R² Score: {r2:.4f}')\n\nnew_data = [[25, 60, 15, 2, 12, 80]]\nnew_data_scaled = scaler.transform(new_data)\nprediction = svr_model.predict(new_data_scaled)\nprint(f'پیش‌بینی قیمت: {prediction[0]:.2f}')\n"
    },
    {
      "type": "text",
      "content": "با تشکر"
    }
  ]
}
